package com.tamirhassan.publisher.model;

import java.util.ArrayList;
import java.util.List;

import com.tamirhassan.publisher.knuthplass.KPGlue;

public class PAFlexMultiCol extends PAFlexContainer
{
	// LAYOUT MODES
	
	// balanced or full height
	// K-P to fill this height
	// +/- one line per page/double page spread
	
	// equal width (container width split proportionally)
	
	// TODO (later):
	// variable width (based on container width, specified, or a mixture)
	// equal column width, fixed height (either of container (or balanced?)), 
	//     variable number of columns (container gets wider)
	
	
	// only first two modes implemented!
	
	public static final int MCOL_EQUAL_WIDTH = 10;
	public static final int MCOL_VAR_WIDTH = 11;
	public static final int MCOL_FIXED_HEIGHT = 12;
	
	// default
	public static final int SINGLE_COL = 0;
	
	// most common multicol mode
	public static final int FIXED_WIDTH_FIXED_NUM_COLS = 10;
	
	// as long as there is enough space for a new column
	// (minColWidthForNew), a new column is created
	// NOT IMPLEMENTED
	public static final int FIXED_WIDTH_DYNAMIC_NUM_COLS = 11;
	
	// does not really make sense at the moment
//	public static final int FIXED_HEIGHT_FIXED_NUM_COLS = 20;
	
	// column width fixed; if enough content, new column created
	// NOT IMPLEMENTED
	public static final int FIXED_HEIGHT_DYNAMIC_NUM_COLS = 21;
	
	// column width also adjusted to accommodate content better
	// NOT IMPLEMENTED
	public static final int FIXED_HEIGHT_DYNAMIC_NUM_COLS_COL_WIDTH = 21;
	
	// idea for the future ...
	// public static final int FIXED_AREA = 30;
	
	// TODO: ruling between columns, etc.
	
	// TODO: move to class ColumnWidthSource?
	float columnWidth;
	
	int layoutMode = 0;
	//int noCols = 1; // can be ignored depending on layoutMode
	int noCols = 2;
	float minColWidthForNew = 200; // in points, as fontsize of content unknown
	                               // TODO: later on feedback
	float gutterWidth = 12;
	boolean balanceCols = false;
	
	// FlexObject allows the use of spaces, penalties and objects such as figures ...
	List<PAFlexObject> content = new ArrayList<PAFlexObject>(); 

	List<Integer> breakpointOffsets = new ArrayList<Integer>();
	
	// possibilities:
	//   fixed width; no of cols fixed; height adjusts to content
	//   fixed height; no of cols variable; adjusts to content
	
	// keep a hash of which lines (and penalties/spaces) are generated by 
	// which paragraph
//	protected HashMap<PAPhysObject, PAFlexBreakableBlock> lineParaMap = null;
	
	public PAFlexMultiCol(int noCols, int layoutMode)
	{
		this.noCols = noCols;
		this.layoutMode = layoutMode;
	}
	
	public PAFlexMultiCol(PAFlexMultiCol existingObj)
	{
		this.noCols = existingObj.noCols;
		this.layoutMode = existingObj.layoutMode;
		this.balanceCols = existingObj.balanceCols;
		this.gutterWidth = existingObj.gutterWidth;
		this.id = existingObj.id;
		
		// TODO: add all other fields
	}
	
	public List<PAFlexObject> getContent() {
		return content;
	}

	public void setContent(List<PAFlexObject> content) {
		this.content = content;
	}

	public float getGutterWidth() {
		return gutterWidth;
	}

	public void setGutterWidth(float gutterWidth) {
		this.gutterWidth = gutterWidth;
	}

	@Override
	public String textContent() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public PAFlexLayoutResult layout(float width, float height) {
		
		System.out.println("*pafmc* in layout of PAFlexMultiCol with height: " + height);
		
		PAPhysHorizSeq retVal = new PAPhysHorizSeq();
		retVal.setFlexID(id);
		
		// determine column placement (separate method)
		float totalColWidth = width - (noCols - 1) * gutterWidth;
		float colWidth = totalColWidth / noCols;
		
		// better work on single column and split - do different widths LATER (is also slower)
		
		// fullheight first
		
		if (true) // TODO: check for other layout modes
		{
			
			if (!balanceCols)
			{
				// fullheight columns, no balancing
				
				int laidOutCols = 0;
				List<PAFlexObject> remainingItems = content;
				
				while(laidOutCols < noCols && remainingItems != null && remainingItems.size() > 0)
				{
					//PAFlexColumn singleFlexCol = new PAFlexColumn(content);
					PAFlexColumn singleFlexCol = new PAFlexColumn(remainingItems);
					singleFlexCol.setID(id);
					PAFlexLayoutResult singleColRes = singleFlexCol.layout(colWidth, height);
					
					if (singleColRes.getExitStatus() == PAFlexLayoutResult.ESTAT_SUCCESS)
					{
						// all content used up
						if (laidOutCols > 0) retVal.getItems().add(new KPGlue(gutterWidth));
						retVal.getItems().add(singleColRes.getResult());
						
						// exit loop
						remainingItems = null;
						
						System.out.println("*pafmc* one");
					}
					else if (singleColRes.getExitStatus() == PAFlexLayoutResult.ESTAT_PARTIAL_SUCCESS)
					{
						// some content used up; some remaining
						if (laidOutCols > 0) retVal.getItems().add(new KPGlue(gutterWidth));
						retVal.getItems().add(singleColRes.getResult());
						
						laidOutCols ++;
						
						// set remaining content
						remainingItems = ((PAFlexColumn)singleColRes.getRemainingContent()).getContent();
						System.out.println("*pafmc* two with remaining items: " + remainingItems.size());
					}
					else if (singleColRes.getExitStatus() == PAFlexLayoutResult.ESTAT_FAIL_INSUFFICIENT_HEIGHT)
					{
						// TODO: insufficient height to place even one object in column
					}
					else
					{
						System.out.println("*pafmc* three");
						System.err.println("problem generating single column!");
					}
				}
				
				if (remainingItems != null && remainingItems.size() > 0)
				{
					System.out.println("*pafmc* four");
					PAFlexMultiCol remainingContent = new PAFlexMultiCol(this); // clone this
					remainingContent.getContent().addAll(remainingItems);
					
					retVal.height = retVal.contentHeight();
					return new PAFlexLayoutResult(retVal, -1.0f, remainingContent,
							PAFlexLayoutResult.ESTAT_PARTIAL_SUCCESS);
				}
				else
				{
					System.out.println("*pafmc* five");
					retVal.height = retVal.contentHeight();
					return new PAFlexLayoutResult(retVal, -1.0f, null,
							PAFlexLayoutResult.ESTAT_SUCCESS);
				}
				
				// TODO: what if no remaining items?!?
				
			}
			else
			{
				// balanceCols == true
				
				// TODO: this section not implemented yet
				
				PAFlexColumn singleFlexCol = new PAFlexColumn(content);
				PAFlexLayoutResult singleColRes = singleFlexCol.layout(colWidth, Float.MAX_VALUE);
				
				if (singleColRes.getExitStatus() == 0)
				{
					System.out.println("*pafmc* eleven");
					PAPhysColumn singleCol = (PAPhysColumn) singleColRes.getResult();
				}
				else
				{
					System.out.println("*pafmc* twelve");
					System.err.println("problem generating single column!");
				}
			}
		
		}
		else
		{
			// TODO: other layout modes
		}
		
		// working on each column in turn enables different column widths (special case, slower)
		
		// options: balanced or full height first
		
		// K-P flexibility required for:
		// (i)  avoiding bad breaks
		// (ii) balancing when not integer divisible
		
		// simplest version simply works as for pages (one line less at bottom if necessary)
		
		// lay out the columns as one VCol
		
		//
		
		// TODO Auto-generated method stub
		return null;
	}

	
}
